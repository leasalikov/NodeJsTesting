"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _IPCClient_instances, _IPCClient_ipc, _IPCClient_ipcChannel, _IPCClient_messageQueue, _IPCClient_writer, _IPCClient_connected, _IPCClient_promises, _IPCClient_emitter, _IPCClient_flush;
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = __importDefault(require("console"));
const events_1 = __importDefault(require("events"));
const node_ipc_1 = require("@achrinza/node-ipc");
const message_writer_1 = __importDefault(require("./message-writer"));
class IPCClient {
    constructor(id) {
        _IPCClient_instances.add(this);
        _IPCClient_ipc.set(this, void 0);
        _IPCClient_ipcChannel.set(this, void 0);
        _IPCClient_messageQueue.set(this, []);
        _IPCClient_writer.set(this, void 0);
        _IPCClient_connected.set(this, false);
        _IPCClient_promises.set(this, new Set());
        _IPCClient_emitter.set(this, new events_1.default());
        const { IPC_CHANNEL, DEBUG_VSCODE_IPC } = process.env;
        if (!IPC_CHANNEL) {
            throw new Error('IPC_CHANNEL is not defined');
        }
        __classPrivateFieldSet(this, _IPCClient_ipcChannel, IPC_CHANNEL, "f");
        __classPrivateFieldSet(this, _IPCClient_ipc, new node_ipc_1.IPC(), "f");
        __classPrivateFieldGet(this, _IPCClient_ipc, "f").config.silent = !DEBUG_VSCODE_IPC;
        __classPrivateFieldGet(this, _IPCClient_ipc, "f").config.id = `jest-runner-vscode-${id}-${process.pid}`;
        __classPrivateFieldGet(this, _IPCClient_ipc, "f").config.logger = (message) => {
            // keep message no longer than 500 characters
            const truncatedMessage = message.length > 500 ? `${message.slice(0, 500)}...\u001b[0m` : message;
            console_1.default.log(truncatedMessage);
        };
        __classPrivateFieldSet(this, _IPCClient_writer, new message_writer_1.default(__classPrivateFieldGet(this, _IPCClient_ipc, "f"), __classPrivateFieldGet(this, _IPCClient_ipcChannel, "f")), "f");
    }
    get on() {
        return __classPrivateFieldGet(this, _IPCClient_emitter, "f").on.bind(__classPrivateFieldGet(this, _IPCClient_emitter, "f"));
    }
    get once() {
        return __classPrivateFieldGet(this, _IPCClient_emitter, "f").once.bind(__classPrivateFieldGet(this, _IPCClient_emitter, "f"));
    }
    get off() {
        return __classPrivateFieldGet(this, _IPCClient_emitter, "f").off.bind(__classPrivateFieldGet(this, _IPCClient_emitter, "f"));
    }
    get removeListener() {
        return __classPrivateFieldGet(this, _IPCClient_emitter, "f").removeListener.bind(__classPrivateFieldGet(this, _IPCClient_emitter, "f"));
    }
    get removeAllListeners() {
        return __classPrivateFieldGet(this, _IPCClient_emitter, "f").removeAllListeners.bind(__classPrivateFieldGet(this, _IPCClient_emitter, "f"));
    }
    async connect() {
        return new Promise((resolve, reject) => {
            __classPrivateFieldGet(this, _IPCClient_ipc, "f").connectTo(__classPrivateFieldGet(this, _IPCClient_ipcChannel, "f"), () => {
                __classPrivateFieldSet(this, _IPCClient_connected, true, "f");
                __classPrivateFieldGet(this, _IPCClient_instances, "m", _IPCClient_flush).call(this)
                    .then(() => {
                    __classPrivateFieldGet(this, _IPCClient_emitter, "f").emit('connect');
                    __classPrivateFieldGet(this, _IPCClient_ipc, "f").of[__classPrivateFieldGet(this, _IPCClient_ipcChannel, "f")].on('disconnect', () => {
                        __classPrivateFieldSet(this, _IPCClient_connected, false, "f");
                        __classPrivateFieldGet(this, _IPCClient_emitter, "f").emit('disconnect');
                    });
                    resolve();
                })
                    .catch(error => {
                    reject(error);
                });
            });
        });
    }
    async disconnect() {
        if (!__classPrivateFieldGet(this, _IPCClient_connected, "f")) {
            return;
        }
        await Promise.all(__classPrivateFieldGet(this, _IPCClient_promises, "f"));
        const disconnected = new Promise(resolve => {
            __classPrivateFieldGet(this, _IPCClient_emitter, "f").once('disconnect', resolve);
        });
        __classPrivateFieldGet(this, _IPCClient_ipc, "f").disconnect(__classPrivateFieldGet(this, _IPCClient_ipcChannel, "f"));
        return disconnected;
    }
    emit(type, data) {
        if (!__classPrivateFieldGet(this, _IPCClient_connected, "f")) {
            __classPrivateFieldGet(this, _IPCClient_messageQueue, "f").push([type, data]);
        }
        else {
            const promise = __classPrivateFieldGet(this, _IPCClient_writer, "f").write(type, data);
            __classPrivateFieldGet(this, _IPCClient_promises, "f").add(promise);
            promise.then(() => __classPrivateFieldGet(this, _IPCClient_promises, "f").delete(promise)).catch(() => undefined);
        }
    }
}
exports.default = IPCClient;
_IPCClient_ipc = new WeakMap(), _IPCClient_ipcChannel = new WeakMap(), _IPCClient_messageQueue = new WeakMap(), _IPCClient_writer = new WeakMap(), _IPCClient_connected = new WeakMap(), _IPCClient_promises = new WeakMap(), _IPCClient_emitter = new WeakMap(), _IPCClient_instances = new WeakSet(), _IPCClient_flush = async function _IPCClient_flush() {
    while (__classPrivateFieldGet(this, _IPCClient_messageQueue, "f").length) {
        const message = __classPrivateFieldGet(this, _IPCClient_messageQueue, "f").shift();
        if (message) {
            const [type, data] = message;
            await __classPrivateFieldGet(this, _IPCClient_writer, "f").write(type, data);
            __classPrivateFieldGet(this, _IPCClient_emitter, "f").emit(type, data);
        }
    }
};
