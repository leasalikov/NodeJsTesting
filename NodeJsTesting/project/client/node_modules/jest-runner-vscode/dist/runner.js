"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_ipc_1 = require("@achrinza/node-ipc");
const path_1 = __importDefault(require("path"));
const process_1 = __importDefault(require("process"));
const cosmiconfig_1 = require("cosmiconfig");
const download_vscode_1 = __importDefault(require("./download-vscode"));
const run_vscode_1 = __importDefault(require("./run-vscode"));
__exportStar(require("./public-types"), exports);
class VSCodeTestRunner {
    constructor(globalConfig, context = {}) {
        this.isSerial = true;
        this._globalConfig = globalConfig;
        this._context = context;
    }
    async runTests(tests, watcher, onStart, onResult, onFailure) {
        const baseVSCodeOptions = (await (0, cosmiconfig_1.cosmiconfig)('jest-runner-vscode').search())
            ?.config ?? {};
        // Runs a separate process for each test directory.
        //
        // VS Code restarts the extension host process any time the open directory
        // changes, so tests that switch between directories cause the child VS Code
        // process to disconnect.
        //
        // To get around this, we run each set of tests that are located in
        // different directories in their own VS Code process. This provides an easy
        // way to run tests that need to be run in different directories.
        //
        // Example:
        //
        //   /project/__tests__/needs_dir1/test1.js
        //   /project/__tests__/needs_dir1/test2.js --> run in the same process
        //   /project/__tests__/needs_dir2/test.js  --> runs in a separate process
        // Group tests by directory.
        const testsByDir = new Map();
        for (const test of tests) {
            const dir = path_1.default.dirname(test.path);
            const existingTests = testsByDir.get(dir);
            if (existingTests) {
                existingTests.push(test);
            }
            else {
                testsByDir.set(dir, [test]);
            }
        }
        // Start IPC server.
        const { DEBUG_VSCODE_IPC } = process_1.default.env;
        const ipc = new node_ipc_1.IPC();
        ipc.config.silent = !DEBUG_VSCODE_IPC;
        ipc.config.id = `jest-runner-vscode-server-${process_1.default.pid}`;
        await new Promise(resolve => {
            ipc.serve(resolve);
            ipc.server.start();
        });
        // Run each group of tests in its own VS Code process.
        for (const [testDir, testGroup] of testsByDir.entries()) {
            if (watcher.isInterrupted()) {
                ipc.server.stop();
                throw Object.assign(new Error(), { name: 'CancelRun' });
            }
            try {
                const vscodeOptions = {
                    ...baseVSCodeOptions,
                    ...((await (0, cosmiconfig_1.cosmiconfig)('jest-runner-vscode').search(testDir))
                        ?.config ?? {}),
                };
                const vscodePath = vscodeOptions.vscodeExecutablePath ??
                    (await (0, download_vscode_1.default)(vscodeOptions.version, vscodeOptions.platform, vscodeOptions.quiet || this._globalConfig.silent, this._globalConfig.json || this._globalConfig.useStderr));
                const args = [
                    '-n',
                    '--no-sandbox',
                    '--disable-workspace-trust',
                    `--extensionDevelopmentPath=${vscodeOptions.extensionDevelopmentPath ?? this._globalConfig.rootDir}`,
                    `--extensionTestsPath=${require.resolve('./child/entry-point')}`,
                    ...(vscodeOptions.openInFolder
                        ? [vscodeOptions.workspaceDir ?? testDir]
                        : []),
                    ...(vscodeOptions.launchArgs ?? []),
                ];
                await (0, run_vscode_1.default)({
                    vscodePath,
                    args,
                    jestArgs: process_1.default.argv.slice(2),
                    env: vscodeOptions.extensionTestsEnv,
                    tests: testGroup,
                    globalConfig: this._globalConfig,
                    filterOutput: vscodeOptions.filterOutput,
                    onStart,
                    onResult,
                    onFailure,
                    ipc,
                    quiet: vscodeOptions.quiet,
                });
            }
            catch (error) {
                for (const test of testGroup) {
                    await onFailure(test, error);
                }
            }
        }
        ipc.server.stop();
    }
}
exports.default = VSCodeTestRunner;
