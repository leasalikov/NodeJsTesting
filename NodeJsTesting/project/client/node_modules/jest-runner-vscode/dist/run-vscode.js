"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = __importDefault(require("child_process"));
const console_1 = __importDefault(require("console"));
async function runVSCode({ vscodePath, args, jestArgs, env, tests, globalConfig, filterOutput, onStart, onResult, onFailure, ipc, quiet, }) {
    return await new Promise(resolve => {
        const useStdErr = globalConfig.json || globalConfig.useStderr;
        const log = useStdErr
            ? console_1.default.error.bind(console_1.default)
            : console_1.default.log.bind(console_1.default);
        const { silent } = globalConfig;
        const remoteOptions = {
            args: jestArgs,
            testPaths: tests.map(test => test.path),
            workspacePath: globalConfig.rootDir,
        };
        const environment = {
            ...process.env,
            NODE_OPTIONS: process.env.NODE_OPTIONS
                ? process.env.NODE_OPTIONS.replace(/(?:--require .+?\.pnp\.c?js|--experimental-loader .+?\.pnp\.loader\.mjs)/g, '')
                : '',
            ...env,
            PARENT_JEST_OPTIONS: JSON.stringify(remoteOptions),
            PARENT_CWD: process.cwd(),
            IPC_CHANNEL: ipc.config.id,
        };
        const testsByPath = new Map();
        for (const test of tests) {
            testsByPath.set(test.path, test);
        }
        const completedTests = new Set();
        const onTestFileResult = async ({ test, testResult, }) => {
            const matchingTest = testsByPath.get(test.path);
            if (!matchingTest) {
                return;
            }
            completedTests.add(matchingTest);
            if (testResult.testExecError) {
                const error = Object.assign(new Error(testResult.testExecError.message ??
                    testResult.testExecError.diagnosticText ??
                    testResult.failureMessage?.replace(/^[^\n]+\n\n?/, '')), { code: undefined, stack: undefined, type: undefined }, testResult.testExecError);
                await onFailure(matchingTest, error);
            }
            else {
                await onResult(matchingTest, testResult);
            }
        };
        const onTestStart = async ({ test }) => {
            const matchingTest = testsByPath.get(test.path);
            if (!matchingTest) {
                return;
            }
            await onStart(matchingTest);
        };
        const onStdout = (str) => {
            if (!silent) {
                process.stdout.write(`${str}\n`);
            }
        };
        const onStderr = (str) => {
            if (!silent) {
                process.stderr.write(`${str}\n`);
            }
        };
        let childError;
        const onError = (error) => {
            childError = error;
            silent || quiet || log(error.stack);
        };
        ipc.server.on('testFileResult', (param) => {
            onTestFileResult(param).catch(onError);
        });
        ipc.server.on('testStart', (param) => {
            onTestStart(param).catch(onError);
        });
        ipc.server.on('testFileStart', (param) => {
            onTestStart(param).catch(onError);
        });
        ipc.server.on('stdout', onStdout);
        ipc.server.on('stderr', onStderr);
        ipc.server.on('error', onError);
        const vscode = child_process_1.default.spawn(vscodePath, args, { env: environment });
        if (!silent && !filterOutput) {
            vscode.stdout.pipe(process.stdout);
            vscode.stderr.pipe(process.stderr);
        }
        let vscodeError;
        vscode.on('error', error => {
            vscodeError = error;
        });
        let exited = false;
        const onExit = async (code, signal) => {
            if (exited) {
                return;
            }
            exited = true;
            const exit = code ?? signal ?? '<unknown>';
            const message = `VS Code exited with exit code ${exit}`;
            if (typeof code !== 'number' || code !== 0) {
                silent || quiet || console_1.default.error(message);
                const error = vscodeError ?? childError ?? new Error(message);
                for (const test of tests) {
                    const completed = completedTests.has(test);
                    if (!completed) {
                        await onFailure(test, error);
                    }
                }
            }
            else {
                silent || quiet || log(message);
                for (const test of tests) {
                    const completed = completedTests.has(test);
                    if (!completed) {
                        await onFailure(test, (childError ??
                            new Error(`No test result returned for ${test.path}`)));
                    }
                }
            }
            ipc.server.off('testFileResult', onTestFileResult);
            ipc.server.off('testStart', onTestStart);
            ipc.server.off('testFileStart', onTestStart);
            ipc.server.off('stdout', onStdout);
            ipc.server.off('stderr', onStderr);
            ipc.server.off('error', onError);
            resolve();
        };
        const onExitWrapper = (code, signal) => {
            onExit(code, signal).catch((error) => {
                onError(error);
                resolve();
            });
        };
        vscode.on('exit', onExitWrapper);
        vscode.on('close', onExitWrapper);
    });
}
exports.default = runVSCode;
